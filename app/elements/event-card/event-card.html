<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-styles/shadow.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../../bower_components/progress-bubble/progress-bubble.html">
<link rel="import" href="../ticktock-icons/ticktock-icons.html">
<link rel="import" href="../calendar-icon/calendar-icon.html">
<link rel="import" href="../dropdown-menu/dropdown-menu.html">
<link rel="import" href="event-collapse-expand-animation.html">
<link rel="import" href="event-margin-expand-animation.html">

<dom-module id="event-card">

<style>
  :host {
    --collapse-content-height: 330px;

    display: block;
    border-bottom: 1px solid rgba(0, 0, 0, 0);
  }

  calendar-icon {
    margin: 16px;
  }

  paper-icon-button {
    color: var(--dark-icon-color);
  }

  paper-item {
    cursor: pointer;
  }

  paper-item iron-icon {
    color: var(--dark-icon-color);
  }

  paper-item iron-icon.right {
    margin-left: 12px;
  }

  a {
    color: inherit;
    text-decoration: none;
  }

  progress-bubble {
    --progress-bubble-stroke-color: var(--primary-color);
    --progress-bubble-bg-stroke-color: var(--accent-grey);
    --progress-bubble-background: rgba(0, 0, 0, 0);
    --progress-bubble-reflection-display: none;
    width: calc(var(--collapse-content-height) - 10px - 32px);
    height: calc(var(--collapse-content-height) - 10px - 32px);
    margin-top: 10px;
    margin-bottom: 32px;
  }

  #material {
    padding: 0;
    background-color: white;
    cursor: default;
    max-width: 600px;
    margin: 0 auto;
  }

  :host([opened]) #material {
    margin-bottom: 16px;
  }

  :host([opened]:not([first])) #material {
    margin-top: 16px;
  }

  #toolbar {
    @apply(--layout-horizontal);
    @apply(--layout-center);
  }

  #nameWrapper {
    @apply(--layout-vertical);
    @apply(--layout-start);
    @apply(--layout-flex);
    margin: 8px;
  }

  :host([event-hidden]) #nameWrapper {
    opacity: .5;
  }

  #name {
    font-size: 16px;
    line-height: 18px;
    max-height: 36px;
    overflow: hidden;
  }

  :host([starred]) #star {
    color: #f8bb03;
  }

  #miniTimer {
    color: var(--secondary-text-color);
    font-weight: 300;
    font-size: .8rem;
  }

  #toolbar paper-icon-button:last-child {
    margin-right: 4px;
  }

  #collapse {
    @apply(--layout-vertical);
    @apply(--layout-center);
    height: 0;
    overflow: hidden;
  }

  :host([opened]) #collapse {
    height: var(--collapse-content-height);
  }

  #bubbleContent {
    @apply(--layout-vertical);
    @apply(--layout-center-center);
    text-shadow: none;
    color: var(--secondary-text-color);
    font-weight: 300;
    width: 100%;
    height: 100%;
  }

  #majorDurationSegment {
    font-size: 2.5rem;
  }

  #minorDurationSegmentsWrapper {
    font-size: 1rem;
    width: 60%;
    text-align: center;
  }

  #minorDurationSegmentsWrapper span {
    display: inline-block;
    margin: 0 2px;
  }
</style>

<template>
  <paper-material
    id="material"
    elevation="[[_getElevation(opened)]]"
    on-tap="toggleExpand"
    animated>

    <div id="toolbar">
      <calendar-icon
        icon="[[_getIcon(calendarHidden)]]"
        color="[[color]]"
        faded="[[_getIconFaded(eventHidden, calendarHidden)]]">
      </calendar-icon>

      <div id="nameWrapper">
        <div id="name">
          [[name]] [[_getNameSuffixText(_isStartDuration)]]
        </div>
        <div id="miniTimer" hidden="[[opened]]">
          [[_getMajorDurationText(_duration)]]
        </div>
      </div>

      <paper-icon-button
        id="star"
        icon="icons:star"
        on-tap="toggleStar">
      </paper-icon-button>

      <dropdown-menu horizontal-offset="8" vertical-offset="0">
        <paper-icon-button
          icon="icons:more-vert"
          class="dropdown-trigger">
        </paper-icon-button>

        <div class="dropdown-content">
          <paper-item on-tap="toggleHide">
            <div>[[_getHideButtonText(eventHidden)]]</div>
          </paper-item>

          <a href="[[link]]" target="_blank">
            <paper-item on-tap="_noPropagation">
              <div>Open in Google Calendar</div>
              <iron-icon class="right" icon="icons:open-in-new"></iron-icon>
            </paper-item>
          </a>
        </div>
      </dropdown-menu>
    </div>

    <div id="collapse">
      <!-- TODO: invert direction -->
      <!-- Pink should extend to the left and grow smaller over time. -->
      <progress-bubble
        stroke-width="15"
        value="[[_duration]]"
        max="[[_getMajorDurationMax(_duration)]]">

        <div id="bubbleContent">
          <div id="majorDurationSegment">
            [[_getMajorDurationText(_duration)]]
          </div>
          <div id="minorDurationSegmentsWrapper">
            <template
              is="dom-repeat"
              items="[[_getMinorDurationSegments(_duration)]]">

              <span>[[item]]</span>
            </template>
          </div>
        </div>
      </progress-bubble>
    </div>
  </paper-material>
</template>

<script>
(function () {
  'use strict';

  var COLLAPSE_CONTENT_HEIGHT = 330;
  var MAX_TIMEOUT_DELAY = Math.pow(2, 31) - 1;

  Polymer({
    is: 'event-card',

    behaviors: [
      Polymer.NeonAnimationRunnerBehavior,
    ],

    properties: {
      eventId: String,
      calendarId: String,
      recurrenceId: String,
      name: String,
      startDateMs: Number,
      endDateMs: Number,
      first: {
        type: Boolean,
        reflectToAttribute: true,
      },
      opened: {
        type: Boolean,
        reflectToAttribute: true,
      },
      starred: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
      },
      eventHidden: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
      },
      calendarHidden: Boolean,
      color: String,
      link: String,
      animationConfig: {
        value: function () {
          var getAnimationConfig = (function (timing) {
            return [
              {
                name: 'event-collapse-expand-animation',
                node: this.$.collapse,
                maxHeight: COLLAPSE_CONTENT_HEIGHT,
                timing: timing,
              },
              {
                name: 'event-margin-expand-animation',
                node: this.$.material,
                isFirst: (function () {
                  return this.first;
                }).bind(this),
                timing: timing,
              },
            ];
          }).bind(this);
          return {
            open: getAnimationConfig({
              duration: 200,
              easing: 'ease-out',
              direction: 'normal',
            }),
            close: getAnimationConfig({
              duration: 200,
              easing: 'ease-in',
              direction: 'reverse',
            }),
          };
        },
      },
      _duration: {
        type: Number,
        value: 0,
      },
      _isStartDuration: {
        type: Boolean,
        value: true,
      },
    },

    observers: [
      '_starChanged(starred)',
      '_hideChanged(eventHidden)',
      '_resetUpdater(startDateMs, endDateMs, opened)',
    ],

    ready: function () {
      this._durationUpdaterId = -1;

      // True for setTimeout, false for requestAnimationFrame.
      this._durationUpdaterIsTimeout = null;
    },

    //
    // Actions
    //

    toggleExpand: function () {
      var opened = !this.opened;
      this.playAnimation(opened ? 'open' : 'close');
      this.fire('event-open-toggled', {
        eventId: this.eventId,
        calendarId: this.calendarId,
        opened: opened,
      });
    },

    toggleStar: function (event) {
      this.starred = !this.starred;
      event.stopPropagation();
    },

    toggleHide: function (event) {
      this.eventHidden = !this.eventHidden;
      event.stopPropagation();
    },

    _updateDuration: function (startDateMs, endDateMs, now) {
      var durationSeconds = Math.floor((startDateMs - now) / 1000);

      if (durationSeconds <= 0) {
        durationSeconds = Math.floor((endDateMs - now) / 1000);

        if (durationSeconds < 0) {
          this.fire('event-finish', {
            calendarId: this.calendarId,
            eventId: this.eventId,
          });
        } else {
          this._isStartDuration = false;
        }
      } else {
        this._isStartDuration = true;
      }

      this._duration = durationSeconds;
    },

    //
    // Getters
    //

    _getElevation: function (opened) {
      return opened ? 2 : 1;
    },

    _getIcon: function (calendarHidden) {
      return calendarHidden ? 'ticktock:calendar-hidden' :
                              'ticktock:calendar';
    },

    _getIconFaded: function (eventHidden, calendarHidden) {
      return eventHidden || calendarHidden;
    },

    _getMajorDurationMax: function (duration) {
      return getMajorDurationMax(duration);
    },

    _getMinorDurationSegments: function (duration) {
      return getDurationSegments(duration).slice(1);
    },

    // Text Getters

    _getNameSuffixText: function (isStartDuration) {
      return isStartDuration ? '' : 'Ends';
    },

    _getMajorDurationText: function (duration) {
      return getDurationSegments(duration, false)[0];
    },

    _getHideButtonText: function (eventHidden) {
      return eventHidden ? 'Unhide' : 'Hide';
    },

    //
    // Observers
    //

    _starChanged: function (starred) {
      if (starred && this.eventHidden) {
        this.eventHidden = false;
      } else {
        this.fire('event-modified', {
          eventId: this.eventId,
          calendarId: this.calendarId,
          starred: this.starred,
          hidden: this.eventHidden,
        });
      }
    },

    _hideChanged: function (hidden) {
      if (hidden && this.starred) {
        this.starred = false;
      } else {
        this.fire('event-modified', {
          eventId: this.eventId,
          calendarId: this.calendarId,
          starred: this.starred,
          hidden: this.eventHidden,
        });
      }
    },

    _resetUpdater: function (startDateMs, endDateMs, opened) {
      if (this._durationUpdaterIsTimeout) {
        clearTimeout(this._durationUpdaterId);
      } else {
        cancelAnimationFrame(this._durationUpdaterId);
      }

      var updateDuration;
      if (opened || needsAnimationFrame(this._duration)) {
        updateDuration = (function () {
          this._updateDuration(startDateMs, endDateMs, Date.now());
          this._durationUpdaterId = requestAnimationFrame(updateDuration);
        }).bind(this);

        this._durationUpdaterId = requestAnimationFrame(updateDuration);
        this._durationUpdaterIsTimeout = false;
      } else {
        updateDuration = (function () {
          this._updateDuration(startDateMs, endDateMs, Date.now());
          var nextUpdate = getNextUpdate(this._duration);
          if (nextUpdate || !needsAnimationFrame(this._duration)) {
            this._durationUpdaterId = setTimeout(updateDuration,
                                                 nextUpdate || 200);
          } else {
            this._resetUpdater(startDateMs, endDateMs, opened);
          }
        }).bind(this);

        updateDuration();
        this._durationUpdaterIsTimeout = true;
      }
    },

    //
    // Event Handlers
    //

    _noPropagation: function (event) {
      event.stopPropagation();
    },
  });

  var S_IN_SECOND = 1;
  var S_IN_MINUTE = S_IN_SECOND * 60;
  var S_IN_HOUR = S_IN_MINUTE * 60;
  var S_IN_DAY = S_IN_HOUR * 24;
  var S_IN_MONTH = S_IN_DAY * 30;
  var S_IN_YEAR = S_IN_DAY * 365;

  var conversionFactors = [
    S_IN_YEAR,
    S_IN_MONTH,
    S_IN_DAY,
    S_IN_HOUR,
    S_IN_MINUTE,
    S_IN_SECOND,
  ];
  var MAX_CONVERSION_FACTOR = S_IN_YEAR * 10;

  var units = {};
  units[S_IN_SECOND] = 'Second';
  units[S_IN_MINUTE] = 'Minute';
  units[S_IN_HOUR] = 'Hour';
  units[S_IN_DAY] = 'Day';
  units[S_IN_MONTH] = 'Month';
  units[S_IN_YEAR] = 'Year';

  /**
   * Calculate how long until the major duration segment will need updating.
   *
   * @param {Number} seconds - duration in seconds.
   * @return {Number} - milisecond time until the next update.
   */
  function getNextUpdate(seconds) {
    var conversionFactor = conversionFactors.find(function (factor) {
      return seconds > factor;
    }) || 1;

    var nextUpdate = (seconds % conversionFactor) * 1000;
    return Math.min(nextUpdate, MAX_TIMEOUT_DELAY);
  }

  function needsAnimationFrame(seconds) {
    return seconds && seconds <= S_IN_MINUTE;
  }

  function getDurationSegments(seconds, multiple) {
    multiple = (multiple === undefined) ? true : multiple;
    var segments = [];
    var number;
    for (var i = 0, len = conversionFactors.length; i < len; i++) {
      number = Math.floor(seconds / conversionFactors[i]);

      if (number || i === len - 1) {
        var segment = String(number) + ' ' + units[conversionFactors[i]];
        if (number !== 1) {
          segment += 's';
        }

        if (!multiple) {
          return [segment];
        } else {
          segments.push(segment);
        }
      }

      seconds = seconds % conversionFactors[i];
    }

    return segments;
  }

  function getMajorDurationMax(seconds) {
    var max;
    for (var i = 0, len = conversionFactors.length; i < len; i++) {
      var number = Math.floor(seconds / conversionFactors[i]);
      if (number) {
        return max || MAX_CONVERSION_FACTOR;
      } else {
        max = conversionFactors[i];
      }
    }

    return 1;
  }
})();
</script>

</dom-module>
